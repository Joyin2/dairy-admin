1 — Top-level features (complete list)
These are all admin-panel features you said you want to cover. I grouped them into functional areas.
A. Authentication & Access
* Admin login / logout (Supabase Auth)

* Multi-factor authentication (optional)

* Session management (refresh tokens)

* Role-based access control (Admin, SuperAdmin — mapped to the 3 system roles: Company Admin, Manufacturer, Delivery Agent)

* Single Sign-On later (OIDC)

B. User & Role Management
   * Create / edit / deactivate users (name, phone, email, role, assigned agent/manufacturer)

   * Bulk import users (CSV)

   * Invite flows (email/SMS)

   * Reset password / force logout

   * View user activity & last login

   * Permission sets UI (view & edit role permissions JSON)

C. Master Data (CRUD)
      * Suppliers (farmers) management — KYC fields, bank info, preferred contact

      * Shops / Retailers management

      * Products / SKUs

      * Routes & Stops (create route templates and assign days)

      * Delivery agents registry (assign to routes)

      * Locations (geo-fencing/warehouse map)

      * Price lists & taxes

D. Milk Collection & Intake
         * View today's collections & historical

         * Filter/sort/search by supplier, date, operator, fat/SNF ranges

         * Collection detail (photo, GPS point, receipt, QC flag)

         * Approve/reject collection (manual QC override)

         * Bulk actions (export, mark approved)

         * Create manual collection (admin entry)

E. Production / Batch Management
            * Create production batch (select inputs/collections, formula, expected yield)

            * Batch detail (input collections, QC reports, tests, photos)

            * Batch QC approval / rejection workflow

            * Batch → finished inventory link

            * Batch expiry & recall flags

F. Inventory & Stock
               * Inventory overview (by product, batch, location)

               * Transfer stock between locations

               * Stock adjustments (reasons, audit)

               * Stock thresholds & alerts (low stock)

               * Stock valuation & FIFO/LIFO reports

G. Route & Delivery Management
                  * Create & edit routes

                  * Assign routes to delivery agents (one-off or scheduled)

                  * View route progress (real-time)

                  * Delivery exceptions (partial/returned/damaged)

                  * Reassign deliveries (drag/drop UI)

H. Delivery & Payments / Ledger
                     * Delivery list & detail (proof photo, signature)

                     * Record offline payments and reconcile

                     * Auto ledger entry creation

                     * Payment refunds & adjustments

                     * Cash reconciliation report

                     * Export invoices/receipts (PDF generation)

I. Reports & Dashboards
                        * Real-time dashboard: collections today, deliveries due, cash-in-hand, stock levels

                        * Production yield reports, supplier performance, fat/SNF trends

                        * Delivery performance (on-time %, returns)

                        * Financial reports: daily collections, payables, receivables

                        * Exports: CSV, XLSX, PDF

J. Notifications & Communications
                           * SMS / Email / Push templates

                           * Send single/bulk notifications (e.g., receipts to suppliers)

                           * Notification logs

K. System & Settings
                              * App settings (pricing, taxes, SMS gateway credentials)

                              * Integrations (payment gateways, SMS provider)

                              * Audit logs (security, financial)

                              * Backups & restore status

                              * Feature flags / toggles

L. Monitoring & Admin Tools
                                 * Job queue monitor (background jobs)

                                 * Supabase/DB metrics: connections, slow queries

                                 * Logs & error tracker integration

                                 * Admin impersonation (view as manufacturer/delivery agent)

________________


2 — Data model (concise schema / important columns)
Below are the core entities and most important columns (use Postgres / Supabase). This is normalized but pragmatic.
                                    * users: id (uuid pk), email, phone, name, role, status, created_at, last_login

                                    * suppliers: id, name, phone, bank_account, address, kyc_status, auto_receipt_pref

                                    * shops: id, name, address, contact, tags

                                    * milk_collections: id, supplier_id, operator_user_id, qty_liters, fat, snf, gps_point (geography), photo_url, qc_status, status, timestamp

                                    * batches: id, batch_code, production_date, input_collection_ids (array), yield_qty, product_id, expiry_date, qc_status, created_by

                                    * inventory_items: id, product_id, batch_id, location_id, qty, uom, last_updated

                                    * routes: id, name, agent_id, date, stops (json array of shop_id, expected_qty, status)

                                    * deliveries: id, route_id, shop_id, items (json), status, delivered_at, proof_url, signature_url, collected_amount

                                    * ledger_entries: id, from_account_id, to_account_id, amount, mode, reference, receipt_url, created_by, created_at

                                    * notifications: id, to, channel, status, message, sent_at

                                    * audit_logs: id, user_id, action_type, entity_type, entity_id, meta_json, timestamp

Indexes to create immediately (will help performance):
                                       * milk_collections(supplier_id, timestamp DESC)

                                       * milk_collections USING GIST (gps_point)

                                       * batches(production_date)

                                       * inventory_items(product_id, location_id)

                                       * deliveries(route_id, status)

                                       * users(email) unique

                                       * Full-text index on suppliers.name, shops.name (pg_trgm)

________________


3 — Exact data flows for all main processes
I’ll give clear step-by-step flows for each core process (who touches what, which table updates happen, and where Supabase/Next.js features should be used).
A. User creation & login (Admin workflow)
                                          1. Admin UI (Next.js page) → POST /api/admin/users (Edge Function or Next.js API route)

                                          2. Server-side: call Supabase Admin API to create user in Auth (supabase.auth.admin.createUser) and create users row with role & metadata.

                                          3. Supabase triggers (Edge Function or DB trigger) write audit_log row user.created.

                                          4. Admin can assign roles/permissions JSON stored in roles table.

                                          5. On login: Next.js uses Supabase client on server side to verify session cookie; return SSR props (server components) with session and user role for RBAC controls.

B. Milk collection (Manufacturer -> Admin visibility)
                                             1. Manufacturer mobile app POSTs to POST /api/milk_collections (or writes directly to Supabase Realtime DB if you allow).

                                             2. Backend validates (supplier exists, operator authorized), writes row to milk_collections.

                                             3. DB trigger function:

                                                * create ledger_entry placeholder if advance payment required

                                                * notify Admin via Realtime channel / Supabase Realtime webhook

                                                   4. Admin Dashboard (Next.js) subscribes to Realtime channel for milk_collections and updates UI instantly (SSE / WebSocket).

                                                   5. Admin can click a collection, approve → update milk_collections.qc_status and write audit_log.

Notes: Use Supabase Realtime for push updates or Postgres NOTIFY + Edge Function pushing to your Next serverless. For the Admin web, use swr + Realtime subscription to show instantly.
C. Batch creation & inventory update
                                                      1. Admin or Manufacturer selects a set of milk_collections and POSTs to POST /api/batches.

                                                      2. Backend transaction:

                                                         * validate collections not already used

                                                         * create batches row

                                                         * create inventory_items row with qty = yield

                                                         * update milk_collections.status = used_in_batch (in same transaction)

                                                         * create audit_logs & QC entries

                                                            3. On success, notify Delivery/Inventory dashboards via Realtime.

                                                            4. Admin UI shows batch and inventory updates immediately.

Important: Use a single DB transaction (Postgres transaction) to avoid partial updates.
D. Route creation & assignment
                                                               1. Admin creates a route: POST /api/routes with stops.

                                                               2. Next.js server writes route into routes table and schedules push notifications to Delivery Agent (Supabase Realtime or Edge Function).

                                                               3. Delivery Agent mobile app pulls assigned routes or receives push; Admin Dashboard displays route calendar.

E. Delivery lifecycle (Delivery Agent → Admin ledger)
                                                                  1. Agent marks delivery.status = delivered and uploads proof_url, signature_url.

                                                                  2. Backend:

                                                                     * update deliveries row

                                                                     * create ledger_entries for collected amount (if any)

                                                                     * if cash, create cash_reconciliation pending approval

                                                                        3. Admin sees delivery update via Realtime and can reconcile cash (approve ledger entries).

                                                                        4. Admin may export invoices for delivered items.

F. Payments & ledger reconciliation
                                                                           1. Payments recorded (from mobile or admin) create ledger_entries.

                                                                           2. Background jobs (Edge Functions) reconcile payments with bank statements (if integrated).

                                                                           3. Admin can view daily reconciliation report; mark ledger entries as cleared once matched.

________________


4 — API & Contracts (suggested endpoints)
Use Next.js API routes or Supabase Edge Functions — prefer Edge Functions for heavy/critical server logic (webhooks, payment handling).
Auth:
                                                                              * POST /api/auth/login

                                                                              * POST /api/auth/logout
 Admin:

                                                                              * GET /api/admin/dashboard

                                                                              * GET /api/admin/users

                                                                              * POST /api/admin/users
 Suppliers / Collections:

                                                                              * GET /api/suppliers

                                                                              * POST /api/milk_collections

                                                                              * GET /api/milk_collections?date=...
 Batches:

                                                                              * POST /api/batches
 Inventory:

                                                                              * GET /api/inventory
 Routes / Deliveries:

                                                                              * POST /api/routes

                                                                              * GET /api/routes/:agentId?date=

                                                                              * POST /api/deliveries/:id/mark-delivered
 Payments:

                                                                              * POST /api/payments
 Realtime:

                                                                              * GET /api/realtime/token (if using client tokens)

Return shapes should be JSON with success, data, error fields and use proper HTTP codes.
________________


5 — Supabase-specific recommendations (security + realtime)
                                                                                 * Row Level Security (RLS): enable RLS on all tables; write policies so only authenticated users or role-bound users can access rows. Example: a delivery agent can only read routes where agent_id = auth.uid().

                                                                                 * Use Supabase Auth metadata for role mapping (store role in user metadata).

                                                                                 * Realtime replication: enable Realtime for tables where you want instant UI updates: milk_collections, deliveries, batches, inventory_items.

                                                                                 * Edge Functions: place payment processing, heavy validations, and scheduled jobs in Edge Functions — these run close to your Next.js front-end and can be called server-side.

                                                                                 * Database triggers: for things that must be atomic and immediate (ledger entry creation on delivery), use Postgres triggers/functions.

                                                                                 * Connection pooling: Supabase handles pooling — but for serverless (Edge Functions / Next.js API routes) ensure you close connections or use Supabase client that is optimized for serverless.

________________


6 — How to make it the fastest loading (near-zero perceived latency)
You asked for “0 time loss” — I’ll translate that to near-instant UI and minimal server roundtrips. Use the following prioritized techniques in order:
6.1 Frontend: perceived instant interactions
                                                                                    * Optimistic UI: For actions like marking delivery, creating collection, update UI immediately (optimistic update) and rollback on failure. Use swr or React Query.

                                                                                    * Local cache + hydration: Preload essential data on server-side render (SSR) and hydrate client. For frequently-changing small datasets (today’s collections), use Realtime + SWR to keep cached copy updated.

                                                                                    * Skeleton loaders instead of spinners — perceived speed is better.

                                                                                    * Debounce + batch user actions (e.g., bulk approvals).

6.2 Next.js rendering strategy (use appropriate mode)
                                                                                       * Server components and server-side rendering (SSR) for initial page render (dashboard) to include authenticated data in HTML (fast Time-to-Interactive).

                                                                                       * Edge rendering (middleware/Edge Functions) for performance-critical APIs.

                                                                                       * ISR (Incremental Static Regeneration) for parts that are semi-static (e.g., product catalog, settings docs) to serve from CDN.

                                                                                       * Client components for interactive parts (tables, filters). Use code splitting and dynamic imports for heavy components.

                                                                                       * Use streaming SSR for large dashboards (render summary first, stream heavy widgets).

6.3 Data fetching & caching
                                                                                          * Cache at CDN / Edge: Cache endpoints that are read-heavy and not super-fresh (last 30s–1m) at edge (Vercel/Netlify). Use cache-control headers carefully.

                                                                                          * Short TTL + Revalidation: For realtime dashboards, use very short TTL (e.g., 10s) with stale-while-revalidate.

                                                                                          * Use Supabase Realtime instead of continuous polling where possible to avoid wasted requests.

                                                                                          * Batch API calls: Combine multiple small API calls into a single endpoint to reduce RTT.

                                                                                          * GraphQL gateway (optional) — combine many related queries into one network call.

6.4 Database speed-ups
                                                                                             * Proper indexing (see list above).

                                                                                             * Materialized views for heavy aggregated reports (refresh at intervals or on-demand). Use REFRESH MATERIALIZED VIEW CONCURRENTLY.

                                                                                             * Stored procedures (PL/pgSQL) for heavy multi-step operations (create batch + consume collections) — reduces client/server roundtrips and ensures transactional integrity.

                                                                                             * Use pagination with keyset (cursor) pagination, not OFFSET for large tables.

6.5 Network & assets
                                                                                                * Serve JS/CSS from CDN (Vercel or your preferred host does this).

                                                                                                * Use Next/Image for optimized images (auto-webp/avif).

                                                                                                * Compress payloads (gzip/brotli).

                                                                                                * Preconnect and preload critical assets and fonts.

                                                                                                * HTTP/2 or HTTP/3 to reduce connection overhead.

6.6 Serverless / Edge considerations
                                                                                                   * Keep Edge Functions small & idempotent.

                                                                                                   * Avoid cold starts: warm critical Edge Functions (ping or keep-alive).

                                                                                                   * Use Supabase Edge Runtime for latency-sensitive tasks.

6.7 Concurrency & scaling
                                                                                                      * Connection pooling: avoid opening DB connections repeatedly; use Supabase server SDK which uses pooled connections.

                                                                                                      * Queue heavy jobs: offload PDF generation, exports, and bank reconciliations to background workers (Edge Functions or a queue like Supabase’s pg_cron or external worker).

                                                                                                      * Rate-limit admin API endpoints to prevent DDOS and accidental floods.

6.8 Perceived-zero strategies (concrete)
                                                                                                         * When admin clicks “Approve Collection”:

                                                                                                            * Immediately mark row as approved in client-side cache (optimistic).

                                                                                                            * Send PATCH /api/milk_collections/:id in background.

                                                                                                            * If success: confirm. If failure: show inline error and revert.

                                                                                                               * For dashboard counts:

                                                                                                                  * Render counts from pre-fetched SSR snapshot.

                                                                                                                  * Subscribe to Realtime for updates; when new event arrives, update counts.

                                                                                                                     * For heavy charts:

                                                                                                                        * Render lightweight metric numbers first; load chart components async (dynamic import). Show cached chart image or placeholder until data loads.

________________


7 — Concrete implementation checklist (priority order)
                                                                                                                           1. Auth & RLS — implement Supabase Auth and RLS policies for core tables. (Block unauthorized reads.)

                                                                                                                           2. DB schema + indexes + triggers — create tables with indexes and write key triggers for ledger creation and audit logs.

                                                                                                                           3. Core APIs (Edge Functions) — implement:

                                                                                                                              * POST /api/milk_collections (with transactional DB writes)

                                                                                                                              * POST /api/batches (DB transaction stored proc)

                                                                                                                              * POST /api/deliveries/:id/mark-delivered

                                                                                                                                 4. Realtime subscriptions — wire up Realtime for collections/deliveries.

                                                                                                                                 5. Admin Dashboard (SSR) — build server-rendered dashboard with summary widgets and client-side Realtime subscription.

                                                                                                                                 6. Optimistic UI mechanics — integrate SWR or React Query patterns for main mutations.

                                                                                                                                 7. Materialized views & aggregation jobs — build daily aggregates and reports.

                                                                                                                                 8. Background worker & Edge functions — for exports, payment reconciliation, SMS sending.

                                                                                                                                 9. Monitoring & alerts — set up logs, slow-query alerts, uptime checks.

                                                                                                                                 10. Load testing — simulate realistic traffic to confirm DB and Edge scaling.

________________


8 — Example code snippets & patterns (high-level)
Supabase RLS skeleton (SQL example)
-- Allow authenticated users to insert milk_collections
CREATE POLICY "insert_collections" ON public.milk_collections
  FOR INSERT
  USING ( auth.role() = 'authenticated' )
  WITH CHECK ( true );


-- Allow delivery agent to read their routes
CREATE POLICY "agent_read_routes" ON public.routes
  FOR SELECT
  USING ( agent_id = auth.uid() );


Next.js + SWR optimistic pattern (pseudo)
// useSWR + optimistic mutate when marking delivery
const { data, mutate } = useSWR('/api/deliveries?date=today');


async function markDelivered(id) {
  // optimistic update
  mutate(prev => prev.map(d => d.id === id ? {...d, status: 'delivered'} : d), false);
  try {
    await fetch(`/api/deliveries/${id}/mark-delivered`, { method: 'POST' });
    mutate(); // revalidate
  } catch (err) {
    // rollback
    mutate();
    toast.error('Delivery failed — try again.');
  }
}


Stored procedure (Postgres) for batch creation (concept)
                                                                                                                                    * create_batch(in input_collection_ids uuid[], in formula json) returns batch_id

                                                                                                                                       * checks collection availability

                                                                                                                                       * creates batch row

                                                                                                                                       * updates collections.status

                                                                                                                                       * creates inventory row

                                                                                                                                       * returns batch_id

________________


9 — Testing & QA plan to keep latency low in production
                                                                                                                                          * Unit tests for stored procedures and Edge Functions.

                                                                                                                                          * Integration tests: simulate full flow (collection → batch → delivery).

                                                                                                                                          * Performance tests:

                                                                                                                                             * Query profiling (EXPLAIN ANALYZE)

                                                                                                                                             * Load test Realtime capacity and background workers

                                                                                                                                             * Cold start tests for Edge Functions

                                                                                                                                                * A/B test optimistic UI vs confirmed flow for trickier operations.

                                                                                                                                                * Observability: instrument synthetic transactions and metrics for request latency, DB CPU, Edge function cold starts.

________________


10 — Monitoring, metrics & SLOs
Track:
                                                                                                                                                   * API P95 latency (goal < 200ms for dashboard APIs)

                                                                                                                                                   * DB slow queries ( > 200ms)

                                                                                                                                                   * Realtime update delivery latency (< 1s preferred)

                                                                                                                                                   * Edge function cold start rate

                                                                                                                                                   * Error rates & application exceptions

________________


11 — Final recommended tech stack choices & settings
                                                                                                                                                      * Frontend: Next.js (app router), React Server Components for SSR widgets.

                                                                                                                                                      * Data layer: Supabase (Postgres), Realtime, Edge Functions.

                                                                                                                                                      * Background jobs: Supabase Edge Functions + pg_cron or small worker service.

                                                                                                                                                      * CDN / Hosting: Vercel (Next.js) or platform with Edge Function support.

                                                                                                                                                      * State management: SWR for caching + optimistic updates (React Query also fine).

                                                                                                                                                      * Authentication: Supabase Auth with JWT; session cookies for SSR.

                                                                                                                                                      * PDFs/Reports: Offload generation to background worker; store in Supabase Storage.

________________


12 — Quick checklist you can act on now (next 48 hours)
                                                                                                                                                         1. Freeze the Admin panel routes & top-level pages (dashboard, users, suppliers, collections, batches, deliveries, ledger, reports).

                                                                                                                                                         2. Create DB schema + essential indexes + RLS policies in Supabase.

                                                                                                                                                         3. Implement 3 Edge Functions: create_collection, create_batch, mark_delivery.

                                                                                                                                                         4. Implement Admin Login + SSR-protected dashboard page with pre-fetched counts.

                                                                                                                                                         5. Wire Realtime subscriptions for milk_collections and deliveries.







below is a production-ready Postgres / Supabase SQL schema you can run in your database. It includes:
                                                                                                                                                            * CREATE EXTENSION lines (useful in Supabase projects),

                                                                                                                                                            * All core tables with constraints,

                                                                                                                                                            * Indexes (including GIST for geo),

                                                                                                                                                            * Row-Level Security (RLS) policies examples,

                                                                                                                                                            * Triggers + trigger functions (ledger auto-create),

                                                                                                                                                            * A stored procedure create_batch(...) that atomically creates a batch, consumes collections, creates inventory, and writes audit logs,

                                                                                                                                                            * One materialized view example for reporting.

You can paste this into Supabase SQL editor (or run with psql). I added comments so you can adapt fields and permission logic as needed.
________________


-- ===== Extensions (Supabase usually allows these) =====
CREATE EXTENSION IF NOT EXISTS "pgcrypto";      -- uuid / gen_random_uuid
CREATE EXTENSION IF NOT EXISTS "pg_trgm";       -- trigram indexes for text search
CREATE EXTENSION IF NOT EXISTS "postgis";       -- if you want geo features (optional)


-- ===== Type enums =====
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'role_type') THEN
    CREATE TYPE role_type AS ENUM ('company_admin','manufacturer','delivery_agent');
  END IF;
END$$;


DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'collection_qc') THEN
    CREATE TYPE collection_qc AS ENUM ('pending','approved','rejected');
  END IF;
END$$;


DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'delivery_status') THEN
    CREATE TYPE delivery_status AS ENUM ('pending','in_transit','delivered','partial','returned','failed');
  END IF;
END$$;


-- ===== Core tables =====


-- Users table (mirror of auth users, store app metadata here)
CREATE TABLE IF NOT EXISTS app_users (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  auth_uid uuid UNIQUE, -- link to Supabase auth.user.id if used
  email text,
  phone text,
  name text,
  role role_type NOT NULL DEFAULT 'manufacturer',
  metadata jsonb DEFAULT '{}'::jsonb,
  status text DEFAULT 'active',
  created_at timestamptz DEFAULT now(),
  last_login timestamptz
);


-- Suppliers (farmers)
CREATE TABLE IF NOT EXISTS suppliers (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  phone text,
  email text,
  address text,
  bank_account jsonb,
  kyc_status text DEFAULT 'pending',
  auto_receipt_pref boolean DEFAULT true,
  created_by uuid REFERENCES app_users(id),
  created_at timestamptz DEFAULT now()
);


-- Shops / Retailers
CREATE TABLE IF NOT EXISTS shops (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  contact text,
  address text,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now()
);


-- Products / SKUs
CREATE TABLE IF NOT EXISTS products (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  sku text UNIQUE,
  name text NOT NULL,
  uom text DEFAULT 'liter',
  shelf_life_days int,
  created_at timestamptz DEFAULT now()
);


-- Milk collections
CREATE TABLE IF NOT EXISTS milk_collections (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id uuid REFERENCES suppliers(id) ON DELETE SET NULL,
  operator_user_id uuid REFERENCES app_users(id) ON DELETE SET NULL,
  qty_liters numeric(10,3) NOT NULL CHECK (qty_liters >= 0),
  fat numeric(5,2),
  snf numeric(5,2),
  gps geometry(Point,4326), -- requires PostGIS
  photo_url text,
  qc_status collection_qc DEFAULT 'pending',
  status text DEFAULT 'new', -- e.g., new, used_in_batch
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now()
);


-- Batches (production)
CREATE TABLE IF NOT EXISTS batches (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  batch_code text UNIQUE,
  production_date timestamptz DEFAULT now(),
  input_collection_ids uuid[] DEFAULT ARRAY[]::uuid[],
  product_id uuid REFERENCES products(id),
  yield_qty numeric(12,3) NOT NULL CHECK (yield_qty >= 0),
  expiry_date date,
  qc_status collection_qc DEFAULT 'pending',
  created_by uuid REFERENCES app_users(id),
  created_at timestamptz DEFAULT now()
);


-- Inventory items (finished goods, batch-based)
CREATE TABLE IF NOT EXISTS inventory_items (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  product_id uuid REFERENCES products(id) ON DELETE CASCADE,
  batch_id uuid REFERENCES batches(id) ON DELETE SET NULL,
  location_id uuid, -- optional location/warehouse ref
  qty numeric(12,3) NOT NULL CHECK (qty >= 0),
  uom text DEFAULT 'liter',
  metadata jsonb DEFAULT '{}'::jsonb,
  last_updated timestamptz DEFAULT now()
);


-- Routes
CREATE TABLE IF NOT EXISTS routes (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text,
  agent_id uuid REFERENCES app_users(id) ON DELETE SET NULL,
  date date,
  stops jsonb DEFAULT '[]'::jsonb, -- array of {shop_id, expected_qty, seq}
  created_at timestamptz DEFAULT now()
);


-- Deliveries
CREATE TABLE IF NOT EXISTS deliveries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  route_id uuid REFERENCES routes(id) ON DELETE CASCADE,
  shop_id uuid REFERENCES shops(id),
  items jsonb DEFAULT '[]'::jsonb, -- array of {product_id, qty, price}
  status delivery_status DEFAULT 'pending',
  expected_qty numeric(12,3),
  delivered_qty numeric(12,3),
  proof_url text,
  signature_url text,
  collected_amount numeric(14,2) DEFAULT 0,
  payment_mode text,
  created_at timestamptz DEFAULT now(),
  delivered_at timestamptz
);


-- Ledger / Payments
CREATE TABLE IF NOT EXISTS ledger_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  from_account text, -- free-form for now (supplier, shop, cash)
  to_account text,
  amount numeric(14,2) NOT NULL CHECK (amount >= 0),
  mode text, -- cash, upi, bank_transfer
  reference text,
  receipt_url text,
  created_by uuid REFERENCES app_users(id),
  created_at timestamptz DEFAULT now(),
  cleared boolean DEFAULT false
);


-- Notifications
CREATE TABLE IF NOT EXISTS notifications (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  "to" text,
  channel text,
  status text DEFAULT 'pending',
  message text,
  metadata jsonb DEFAULT '{}'::jsonb,
  sent_at timestamptz
);


-- Audit logs
CREATE TABLE IF NOT EXISTS audit_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES app_users(id),
  action_type text,
  entity_type text,
  entity_id uuid,
  meta jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now()
);


-- ===== Indexes (performance) =====
CREATE INDEX IF NOT EXISTS idx_milk_collections_supplier_ts ON milk_collections (supplier_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_milk_collections_qc_status ON milk_collections (qc_status);
CREATE INDEX IF NOT EXISTS idx_batches_production_date ON batches (production_date DESC);
CREATE INDEX IF NOT EXISTS idx_inventory_product_location ON inventory_items (product_id, location_id);
CREATE INDEX IF NOT EXISTS idx_deliveries_route_status ON deliveries (route_id, status);
CREATE INDEX IF NOT EXISTS idx_suppliers_name_trgm ON suppliers USING gin (name gin_trgm_ops);
CREATE INDEX IF NOT EXISTS idx_shops_name_trgm ON shops USING gin (name gin_trgm_ops);


-- GIST index for geography (requires PostGIS)
CREATE INDEX IF NOT EXISTS idx_milk_collections_gps ON milk_collections USING GIST (gps);


-- ===== Row Level Security (RLS) policies =====
-- Enable RLS on sensitive tables
ALTER TABLE app_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE milk_collections ENABLE ROW LEVEL SECURITY;
ALTER TABLE batches ENABLE ROW LEVEL SECURITY;
ALTER TABLE deliveries ENABLE ROW LEVEL SECURITY;
ALTER TABLE routes ENABLE ROW LEVEL SECURITY;
ALTER TABLE ledger_entries ENABLE ROW LEVEL SECURITY;


-- Helper function: returns role from JWT custom claim "role" or lookup table
-- In Supabase you may set role as user_metadata; here we assume auth has claim 'role'
-- For policy examples we use auth.role() or auth.uid()


/* Policies for app_users */
CREATE POLICY app_users_select_company_admin ON app_users
  FOR SELECT USING ( current_setting('jwt.claims.role', true) = 'company_admin' OR auth.uid()::text = auth_uid::text );


CREATE POLICY app_users_update_self ON app_users
  FOR UPDATE USING ( auth.uid()::text = auth_uid::text );


-- Milk collections: manufacturers and admin can insert; manufacturers can read their entries; admin can read all
CREATE POLICY milk_collections_insert ON milk_collections
  FOR INSERT USING ( current_setting('jwt.claims.role', true) IN ('company_admin','manufacturer') )
  WITH CHECK ( current_setting('jwt.claims.role', true) IN ('company_admin','manufacturer') );


CREATE POLICY milk_collections_select_manufacturer ON milk_collections
  FOR SELECT USING (
    current_setting('jwt.claims.role', true) = 'company_admin'
    OR (current_setting('jwt.claims.role', true) = 'manufacturer' AND operator_user_id::text = auth.uid()::text)
  );


CREATE POLICY milk_collections_update_for_admin ON milk_collections
  FOR UPDATE USING ( current_setting('jwt.claims.role', true) = 'company_admin' );


-- Batches: only company_admin or manufacturer that created it can select/insert/update
CREATE POLICY batches_insert ON batches
  FOR INSERT USING ( current_setting('jwt.claims.role', true) IN ('company_admin','manufacturer') )
  WITH CHECK ( current_setting('jwt.claims.role', true) IN ('company_admin','manufacturer') );


CREATE POLICY batches_select ON batches
  FOR SELECT USING (
    current_setting('jwt.claims.role', true) = 'company_admin'
    OR (current_setting('jwt.claims.role', true) = 'manufacturer' AND created_by::text = auth.uid()::text)
  );


-- Routes: admin create/select; delivery agent can select routes assigned to them
CREATE POLICY routes_select_agent ON routes
  FOR SELECT USING (
    current_setting('jwt.claims.role', true) = 'company_admin'
    OR (current_setting('jwt.claims.role', true) = 'delivery_agent' AND agent_id::text = auth.uid()::text)
  );


CREATE POLICY routes_insert_admin ON routes
  FOR INSERT USING ( current_setting('jwt.claims.role', true) = 'company_admin' );


-- Deliveries: delivery_agent can update their deliveries; admin can read all
CREATE POLICY deliveries_select ON deliveries
  FOR SELECT USING (
    current_setting('jwt.claims.role', true) = 'company_admin'
    OR (current_setting('jwt.claims.role', true) = 'delivery_agent' AND route_id IN (SELECT id FROM routes WHERE agent_id::text = auth.uid()::text))
  );


CREATE POLICY deliveries_update_agent ON deliveries
  FOR UPDATE USING (
    current_setting('jwt.claims.role', true) = 'company_admin'
    OR (current_setting('jwt.claims.role', true) = 'delivery_agent' AND route_id IN (SELECT id FROM routes WHERE agent_id::text = auth.uid()::text))
  );


-- Ledger entries: only admin can see all; creators can see their created entries
CREATE POLICY ledger_entries_select ON ledger_entries
  FOR SELECT USING (
    current_setting('jwt.claims.role', true) = 'company_admin'
    OR (created_by::text = auth.uid()::text)
  );


CREATE POLICY ledger_entries_insert ON ledger_entries
  FOR INSERT USING ( current_setting('jwt.claims.role', true) IN ('company_admin','delivery_agent') )
  WITH CHECK ( current_setting('jwt.claims.role', true) IN ('company_admin','delivery_agent') );


-- Audit logs: only admin can read
CREATE POLICY audit_logs_select_admin ON audit_logs
  FOR SELECT USING ( current_setting('jwt.claims.role', true) = 'company_admin' );


-- ===== Trigger functions =====


-- Trigger: when a delivery is marked delivered and collected_amount > 0, create ledger entry
CREATE OR REPLACE FUNCTION fn_create_ledger_on_delivery()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF (TG_OP = 'UPDATE' AND NEW.status = 'delivered') OR (TG_OP = 'INSERT' AND NEW.status = 'delivered') THEN
    IF COALESCE(NEW.collected_amount,0) > 0 THEN
      INSERT INTO ledger_entries (from_account, to_account, amount, mode, reference, receipt_url, created_by, created_at)
      VALUES (
        (SELECT name FROM shops WHERE id = NEW.shop_id),  -- from_account
        'company_cash',                                   -- to_account (example)
        NEW.collected_amount,
        NEW.payment_mode,
        NEW.id::text,
        NEW.proof_url,
        current_setting('jwt.claims.user_id', true)::uuid, -- note: fallback, adapt as needed
        now()
      );
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


-- Attach trigger on deliveries
DROP TRIGGER IF EXISTS trg_delivery_create_ledger ON deliveries;
CREATE TRIGGER trg_delivery_create_ledger
AFTER INSERT OR UPDATE ON deliveries
FOR EACH ROW
EXECUTE FUNCTION fn_create_ledger_on_delivery();


-- Trigger: write audit log on important table changes (collections/batches/deliveries)
CREATE OR REPLACE FUNCTION fn_audit_log()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  v_user uuid;
BEGIN
  BEGIN
    v_user := current_setting('jwt.claims.user_id', true)::uuid;
  EXCEPTION WHEN OTHERS THEN
    v_user := NULL;
  END;


  INSERT INTO audit_logs (user_id, action_type, entity_type, entity_id, meta, created_at)
  VALUES (
    v_user,
    TG_OP || '_' || TG_TABLE_NAME,
    TG_TABLE_NAME,
    COALESCE(NEW.id, OLD.id),
    row_to_json(COALESCE(NEW, OLD))::jsonb,
    now()
  );
  RETURN NEW;
END;
$$;


DROP TRIGGER IF EXISTS trg_audit_collections ON milk_collections;
CREATE TRIGGER trg_audit_collections
AFTER INSERT OR UPDATE OR DELETE ON milk_collections
FOR EACH ROW
EXECUTE FUNCTION fn_audit_log();


DROP TRIGGER IF EXISTS trg_audit_batches ON batches;
CREATE TRIGGER trg_audit_batches
AFTER INSERT OR UPDATE OR DELETE ON batches
FOR EACH ROW
EXECUTE FUNCTION fn_audit_log();


DROP TRIGGER IF EXISTS trg_audit_deliveries ON deliveries;
CREATE TRIGGER trg_audit_deliveries
AFTER INSERT OR UPDATE OR DELETE ON deliveries
FOR EACH ROW
EXECUTE FUNCTION fn_audit_log();


-- ===== Stored procedure: atomic batch creation =====
-- Usage:
-- SELECT * FROM create_batch(p_created_by_uuid, p_input_collection_ids_array, p_product_id, p_yield_qty, p_expiry_date, p_batch_code);


CREATE OR REPLACE FUNCTION create_batch(
  p_created_by uuid,
  p_input_collection_ids uuid[],
  p_product_id uuid,
  p_yield_qty numeric,
  p_expiry_date date,
  p_batch_code text DEFAULT NULL
)
RETURNS TABLE(batch_id uuid) AS
$$
DECLARE
  v_batch_id uuid;
  v_conflicts int;
  v_generated_batch_code text;
BEGIN
  -- Basic validation
  IF p_yield_qty < 0 THEN
    RAISE EXCEPTION 'yield must be non-negative';
  END IF;


  IF array_length(p_input_collection_ids,1) IS NULL THEN
    RAISE EXCEPTION 'input collections required';
  END IF;


  -- Check all collections exist and are not already used
  SELECT COUNT(*) INTO v_conflicts
  FROM milk_collections mc
  WHERE mc.id = ANY(p_input_collection_ids) AND mc.status <> 'new';


  IF v_conflicts > 0 THEN
    RAISE EXCEPTION 'one or more collections are already used or not in new state';
  END IF;


  -- Optionally generate batch code
  IF p_batch_code IS NULL THEN
    v_generated_batch_code := 'BATCH-' || to_char(now(),'YYYYMMDD-HH24MISS') || '-' || substring(gen_random_uuid()::text,1,6);
  ELSE
    v_generated_batch_code := p_batch_code;
  END IF;


  -- Transactional work
  PERFORM pg_advisory_xact_lock( (hashtext(v_generated_batch_code))::bigint ); -- simple lock to avoid dup codes


  INSERT INTO batches (batch_code, production_date, input_collection_ids, product_id, yield_qty, expiry_date, qc_status, created_by, created_at)
  VALUES (v_generated_batch_code, now(), p_input_collection_ids, p_product_id, p_yield_qty, p_expiry_date, 'pending', p_created_by, now())
  RETURNING id INTO v_batch_id;


  -- Mark collections as used_in_batch
  UPDATE milk_collections
  SET status = 'used_in_batch'
  WHERE id = ANY(p_input_collection_ids);


  -- Create inventory item for finished goods
  INSERT INTO inventory_items (product_id, batch_id, location_id, qty, uom, metadata, last_updated)
  VALUES (p_product_id, v_batch_id, NULL, p_yield_qty, 'liter', jsonb_build_object('created_by', p_created_by::text, 'input_collections', p_input_collection_ids), now());


  -- Audit log entry (use audit trigger already in place, but we also insert explicit log)
  INSERT INTO audit_logs (user_id, action_type, entity_type, entity_id, meta, created_at)
  VALUES (p_created_by, 'create_batch', 'batches', v_batch_id, jsonb_build_object('input_collections', p_input_collection_ids, 'yield_qty', p_yield_qty), now());


  RETURN QUERY SELECT v_batch_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER; -- SECURITY DEFINER so app role can call; ensure function owner is a trusted role


-- Grant execute to authenticated role (change role as per your schema)
GRANT EXECUTE ON FUNCTION create_batch(uuid, uuid[], uuid, numeric, date, text) TO public;


-- ===== Materialized view example (daily collection summary) =====
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_daily_collections AS
SELECT
  date_trunc('day', created_at) AS day,
  count(*) AS total_collections,
  sum(qty_liters) AS total_liters,
  avg(fat) AS avg_fat
FROM milk_collections
GROUP BY date_trunc('day', created_at)
WITH NO DATA;


-- Refresh function for materialized view (can be scheduled)
CREATE OR REPLACE FUNCTION refresh_mv_daily_collections()
RETURNS void LANGUAGE sql AS $$
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_daily_collections;
$$;


-- ===== Convenience: sample grant for admin role (optional) =====
-- If you have a Postgres role for admins, you can grant select on reports
-- GRANT SELECT ON mv_daily_collections TO your_admin_role;


-- ===== Example helper queries (use in app) =====
-- 1) Get today's collections:
-- SELECT * FROM milk_collections WHERE created_at >= (now()::date) ORDER BY created_at DESC;


-- 2) Call create_batch:
-- SELECT * FROM create_batch('00000000-0000-0000-0000-000000000000', ARRAY['uuid1','uuid2']::uuid[], 'product-uuid', 120.5, '2025-12-31', NULL);


-- ===== End of schema =====


________________


Notes & next steps
                                                                                                                                                               1. Adapt claims usage: In RLS I used current_setting('jwt.claims.role', true) and current_setting('jwt.claims.user_id', true) — Supabase injects JWT claims differently depending on configuration. If you're using Supabase's JWT, set custom claims (e.g., role, user_id) or replace those policy checks with auth.uid() and lookups against app_users.auth_uid. Example: auth.uid()::text = operator_user_id::text is simpler and widely used.

                                                                                                                                                               2. Security: SECURITY DEFINER on create_batch makes it runnable by less-permissioned roles — set the function owner to a DB role you control, and be cautious with input validation.

                                                                                                                                                               3. Triggers & audit: The audit trigger uses current_setting('jwt.claims.user_id', true) which depends on how your environment sets JWT claims; you can also pass current_user via Postgres session variables from your Edge Function.

                                                                                                                                                               4. Performance: After creating tables, populate realistic indexes and evaluate EXPLAIN ANALYZE on heavy queries. For aggregations, use materialized views.

                                                                                                                                                               5. Supabase specifics: If you're using Supabase Auth, consider storing auth.uid() in app_users.auth_uid so you can easily map RLS auth.uid() to application-level rows.